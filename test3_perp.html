<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
  <title>Country Pictures</title>
<style>
.autocomplete {
  position: relative;
  display: inline-block;
}

.autocomplete-items {
  position: absolute;
  border: 1px solid #d4d4d4;
  border-bottom: none;
  border-top: none;
  z-index: 99;
  top: 100%;
  left: 0;
  right: 0;
  font-family: sans-serif;
}

.autocomplete-items div {
  padding: 10px;
  cursor: pointer;
  background-color: #fff; 
  border-bottom: 1px solid #d4d4d4; 
}

.autocomplete-items div:hover {
  background-color: #e9e9e9; 
}

.autocomplete-active {
  background-color: DodgerBlue !important; 
  color: #ffffff; 
}

.autocomplete-active {
  background-color: DodgerBlue !important; 
  color: #ffffff; 
}
</style>
</head>
<body>
<div class="autocomplete">
  <input type="text" id="countryInput" placeholder="Type a country name">
  <div id="autocomplete-list" class="autocomplete-items"></div>
</div>
<div id="countryImages"></div>
<script>
let countryData = {};
let flatCountryData = [];
const IMAGE_PATH = 'https://robbieandrew.github.io/GCB2023/SVG/ctry/';
const IMAGE_TYPES = [
	{ prefix: 's20_Coal_Oil_Gas_Cement', extension: 'svg'}
];

// Fetch the JSON data
fetch('https://robbieandrew.github.io/data/countryData.json')
  .then(response => response.json())
  .then(data => {
    countryData = data;
	flatCountryData = Object.entries(countryData).map(
		([code, data]) => ({
			mainName: code,
			isoCode: data.isoCode,
			variants: [code, ...data.variants]
			})
		);
    // Initialize autocomplete after data is loaded
    autocomplete(document.getElementById("countryInput"));
  })
  .catch(error => console.error('Error loading country data:', error));

function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

function downloadSVGasPNG(svgObject) {
  const svg = svgObject.contentDocument.querySelector('svg');
  
  // Create a canvas element
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // Set canvas dimensions to match the SVG
  const svgRect = svg.getBoundingClientRect();
  canvas.width = 1024;
  canvas.height = svgRect.height/svgRect.width*canvas.width;
  
  // Convert SVG to a data URL
  const svgData = new XMLSerializer().serializeToString(svg);
  const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
  const DOMURL = window.URL || window.webkitURL || window;
  const svgUrl = DOMURL.createObjectURL(svgBlob);
  
  // Create an image from the SVG
  const img = new Image();
  img.onload = function() {
	// First draw a white background
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    // Then draw the image on the canvas
    ctx.drawImage(img, 0, 0);
    DOMURL.revokeObjectURL(svgUrl);
    
    // Convert canvas to PNG and initiate download
    canvas.toBlob(function(blob) {
      const url = DOMURL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${svgObject.getAttribute('data').split('/').pop().replace('.svg', '')}.png`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      DOMURL.revokeObjectURL(url);
    }, 'image/png');
  };
  img.src = svgUrl;
}

function addDownloadLink(svgObject) {
  const container = svgObject.parentNode;
  // Create the link
  const downloadLink = document.createElement('a');
  downloadLink.href = '#';
  downloadLink.textContent = 'Download as PNG';
  downloadLink.className = 'download-link';
  // Add click event
  downloadLink.addEventListener('click', (e) => {
    e.preventDefault();
    downloadSVGasPNG(svgObject);
  });
  // Append the link after the SVG object
  container.appendChild(downloadLink);
}

function displayCountryImages(isoCode) {
  const imageContainer = document.getElementById("countryImages");
  imageContainer.innerHTML = ''; // Clear previous images

  IMAGE_TYPES.forEach(({ prefix, extension }) => {
    // if the file has extension svg, create an object, else create an img
    const imageElement = extension === 'svg' ? document.createElement("object") : document.createElement("img");
    
    imageElement.style.width = "600px"; // Set a default width, adjust as needed
    imageElement.style.margin = "10px";
    
    const imagePath = `${IMAGE_PATH}${prefix}_${isoCode}.${extension}`;
    
    if (extension === 'svg') {
      imageElement.data = imagePath;
      imageElement.type = "image/svg+xml";
      imageElement.className = "svg-object";
      imageElement.onerror = () => {
        console.error(`Failed to load SVG: ${imagePath}`);
        imageElement.remove(); // Remove the failed object from DOM
      };
    } else {
      imageElement.src = imagePath;
      imageElement.alt = `${isoCode} Image ${prefix}`;
      imageElement.onerror = () => {
        console.error(`Failed to load image: ${imagePath}`);
        imageElement.remove(); // Remove the failed image from DOM
      };
    }

	// Create a new div to wrap the image
    const wrapperDiv = document.createElement("div");
    wrapperDiv.className = "image-container";
    wrapperDiv.appendChild(imageElement);

    console.log(`Attempting to load: ${imagePath}`);
	// Add the new element to the page inside the container
    imageContainer.appendChild(wrapperDiv);

	// Add a download link for every SVG on the page
	document.querySelectorAll('object[type="image/svg+xml"]').forEach(svgObject => {
	  svgObject.addEventListener('load', () => addDownloadLink(svgObject));
	});
	
  });
}

function scoreMatch(variant, input) {
  const lowerVariant = variant.toLowerCase();
  const lowerInput = input.toLowerCase();
  
  if (lowerVariant.startsWith(lowerInput)) {
    return 100 - lowerVariant.length; // Prioritize shorter, exact matches
  } else if (lowerVariant.includes(lowerInput)) {
    return 50 - lowerVariant.indexOf(lowerInput); // Prioritize earlier matches
  }
  return 0; // No match
}

function autocomplete(inp) {
  const MAX_RESULTS = 10;
  let currentFocus = -1;
  
  const showResults = debounce((inputValue) => {
    const lowerInput = inputValue.toLowerCase();
    
    // Score and sort the matches
    const scoredMatches = flatCountryData
      .map(item => {
        const bestVariantMatch = item.variants.reduce((best, variant) => {
          const score = scoreMatch(variant, lowerInput);
          return score > best.score ? { variant, score } : best;
        }, { variant: '', score: -1 });
        
        return { ...item, matchedVariant: bestVariantMatch.variant, score: bestVariantMatch.score };
      })
      .filter(item => item.score > 0)
      .sort((a, b) => b.score - a.score)
      .slice(0, MAX_RESULTS);

    const listContainer = document.getElementById("autocomplete-list");
    listContainer.innerHTML = '';
    currentFocus = -1;

    if (scoredMatches.length > 0) {
      const fragment = document.createDocumentFragment();
      scoredMatches.forEach((item, index) => {
        const div = document.createElement("div");
        div.setAttribute('data-index', index);
        
        // Create main name element
        const mainNameSpan = document.createElement('span');
        mainNameSpan.style.fontWeight = 'bold';
        
        // Highlight matching part in main name
        const mainNameLower = item.mainName.toLowerCase();
        const matchIndex = mainNameLower.indexOf(lowerInput);
        if (matchIndex >= 0) {
		  const beforeMatch = item.mainName.substring(0, matchIndex);
		  const match = item.mainName.substr(matchIndex, inputValue.length);
		  const afterMatch = item.mainName.substring(matchIndex + inputValue.length);
		  mainNameSpan.innerHTML = `${beforeMatch}<strong>${match}</strong>${afterMatch}`;
        } else {
          mainNameSpan.textContent = item.mainName;
        }
        
        // Create variant element
        const variantSpan = document.createElement('span');
        variantSpan.style.fontSize = '0.8em';
        variantSpan.style.color = '#666';
        variantSpan.style.marginLeft = '0.5em';
        
        // Highlight matching part in variant
		const variantMatchIndex = item.matchedVariant.toLowerCase().indexOf(lowerInput);
		if (variantMatchIndex >= 0) {
		  const beforeMatch = item.matchedVariant.substring(0, variantMatchIndex);
		  const match = item.matchedVariant.substr(variantMatchIndex, inputValue.length);
		  const afterMatch = item.matchedVariant.substring(variantMatchIndex + inputValue.length);
		  variantSpan.innerHTML = `(${beforeMatch}<strong>${match}</strong>${afterMatch})`;
		} else {
		  variantSpan.textContent = `(${item.matchedVariant})`;
		}
        
        // Append both to the div
        div.appendChild(mainNameSpan);
        if (item.matchedVariant !== item.mainName.toLowerCase()) {
          div.appendChild(variantSpan);
        }

        div.addEventListener("click", function() {
          selectItem(item);
        });
        fragment.appendChild(div);
      });
      listContainer.appendChild(fragment);
    } else if (inputValue) {
      const noMatch = document.createElement("div");
      noMatch.innerHTML = '<i>No matches found</i>';
      noMatch.style.padding = '10px';
      noMatch.style.color = '#888';
      noMatch.style.cursor = 'default';
      listContainer.appendChild(noMatch);
    }
  }, 300);

  function selectItem(item) {
    inp.value = `${item.mainName} (${item.isoCode})`;
    closeDropdown();
    displayCountryImages(item.isoCode);
  }
  
  function closeDropdown() {
    const listContainer = document.getElementById("autocomplete-list");
    listContainer.innerHTML = '';
    currentFocus = -1;
  }

  function addActive(x) {
    if (!x) return false;
    removeActive(x);
    if (currentFocus >= x.length) currentFocus = 0;
    if (currentFocus < 0) currentFocus = (x.length - 1);
    x[currentFocus].classList.add("autocomplete-active");
  }

  function removeActive(x) {
    for (let i = 0; i < x.length; i++) {
      x[i].classList.remove("autocomplete-active");
    }
  }

  inp.addEventListener("input", function() {
    showResults(this.value);
  });

  inp.addEventListener("keydown", function(e) {
    const listContainer = document.getElementById("autocomplete-list");
    let x = listContainer.getElementsByTagName("div");
    if (e.key === "ArrowDown") {
      currentFocus++;
      addActive(x);
    } else if (e.key === "ArrowUp") {
      currentFocus--;
      addActive(x);
    } else if (e.key === "Enter") {
      e.preventDefault();
      if (currentFocus > -1) {
        if (x) x[currentFocus].click();
      } else if (x.length > 0) {
        // If no item is focused, select the first item
        x[0].click();
      }
    } else if (e.key === "Escape") {
      closeDropdown();
    }
  });

  document.addEventListener("click", function(e) {
    if (e.target !== inp) {
      closeDropdown();
    }
  });
  
  inp.focus();
}

// Initialize
autocomplete(document.getElementById("countryInput"));

</script>
</body>
</html>
